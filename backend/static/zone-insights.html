<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zone Insights - Butik - Theria</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- Flatpickr for advanced date picker -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr@4.6.13/dist/flatpickr.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr@4.6.13/dist/themes/dark.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr@4.6.13/dist/flatpickr.min.js"></script>
    <!-- Fonts for premium card design -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Outfit:wght@400;500;600&family=JetBrains+Mono:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a202c;
            min-height: 100vh;
            padding: 20px;
            color: #f7fafc;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: #2d3748;
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 28px;
            color: #f7fafc;
            margin: 0;
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .breadcrumb a {
            color: #4fd1c5;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .controls-bar {
            background: #2d3748;
            padding: 15px 30px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .time-range-selector {
            display: flex;
            gap: 8px;
        }

        .range-btn {
            padding: 8px 16px;
            border: 2px solid #4fd1c5;
            background: #2d3748;
            color: #4fd1c5;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .range-btn:hover {
            background: #1a202c;
        }

        .range-btn.active {
            background: #4fd1c5;
            color: #1a202c;
        }

        .refresh-btn {
            padding: 8px 20px;
            background: #4fd1c5;
            color: #1a202c;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .refresh-btn:hover {
            background: #38b2ac;
        }

        .zone-overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        /* PREMIUM ZONE CARD DESIGN */
        .zone-card {
            background: linear-gradient(135deg, #2d3748 0%, #1e2836 100%);
            border-radius: 20px;
            padding: 24px;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(79, 209, 197, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .zone-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg,
                transparent 0%,
                #4fd1c5 50%,
                transparent 100%);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .zone-card:hover {
            transform: translateY(-4px);
            border-color: rgba(79, 209, 197, 0.3);
            box-shadow:
                0 8px 30px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(79, 209, 197, 0.1),
                0 0 60px rgba(79, 209, 197, 0.1);
        }

        .zone-card:hover::before {
            opacity: 1;
        }

        .zone-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(circle at 20% 80%, rgba(79, 209, 197, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(79, 209, 197, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .zone-card > * {
            position: relative;
            z-index: 1;
        }

        .zone-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .zone-card-header h3 {
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #f7fafc;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zone-card-header h3::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #4fd1c5;
            border-radius: 50%;
            box-shadow: 0 0 10px #4fd1c5;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        .zone-content {
            display: grid;
            grid-template-columns: 160px 1fr;
            gap: 20px;
            align-items: stretch;
        }

        .temp-gauge {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .gauge-container {
            position: relative;
            width: 140px;
            height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gauge-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .gauge-bg {
            fill: none;
            stroke: rgba(79, 209, 197, 0.1);
            stroke-width: 8;
        }

        .gauge-progress {
            fill: none;
            stroke: url(#gaugeGradient);
            stroke-width: 8;
            stroke-linecap: round;
            transition: stroke-dashoffset 1s cubic-bezier(0.4, 0, 0.2, 1);
            filter: drop-shadow(0 0 8px rgba(79, 209, 197, 0.6));
        }

        .temp-display {
            position: relative;
            z-index: 1;
            text-align: center;
        }

        .current-temp {
            font-family: 'JetBrains Mono', monospace;
            font-size: 48px;
            font-weight: 700;
            line-height: 1;
            background: linear-gradient(135deg, #4fd1c5 0%, #38b2ac 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -2px;
        }

        .temp-unit {
            font-size: 20px;
            opacity: 0.7;
        }

        .temp-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #a0aec0;
            margin-top: 4px;
            font-weight: 600;
        }

        .zone-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .metric {
            background: rgba(26, 32, 44, 0.5);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(79, 209, 197, 0.08);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .metric::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--metric-color, #4fd1c5);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .metric:hover {
            background: rgba(26, 32, 44, 0.8);
            border-color: rgba(79, 209, 197, 0.2);
            transform: translateY(-2px);
        }

        .metric:hover::before {
            opacity: 1;
        }

        .metric-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #718096;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
        }

        .metric-icon {
            width: 12px;
            height: 12px;
            opacity: 0.6;
        }

        .metric-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #f7fafc;
            line-height: 1.2;
        }

        .metric-value-small {
            font-size: 16px;
        }

        .metric-target { --metric-color: #4fd1c5; }
        .metric-heating { --metric-color: #f56565; }
        .metric-cooling { --metric-color: #4299e1; }
        .metric-samples { --metric-color: #9f7aea; }

        .rate-arrow {
            display: inline-block;
            margin-right: 2px;
            font-size: 16px;
        }

        .heating-arrow { color: #f56565; }
        .cooling-arrow { color: #4299e1; }

        .confidence-metric {
            grid-column: 1 / -1;
            background: rgba(26, 32, 44, 0.5);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(79, 209, 197, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .confidence-label-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .confidence-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #718096;
            font-weight: 600;
        }

        .confidence-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            line-height: 1;
        }

        .confidence-bar {
            flex: 1;
            height: 8px;
            background: rgba(79, 209, 197, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--confidence-color) 0%, var(--confidence-color-light) 100%);
            border-radius: 4px;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px var(--confidence-color);
        }

        .confidence-low {
            --confidence-color: #e53e3e;
            --confidence-color-light: #fc8181;
            color: #e53e3e;
        }

        .confidence-medium {
            --confidence-color: #ed8936;
            --confidence-color-light: #f6ad55;
            color: #ed8936;
        }

        .confidence-high {
            --confidence-color: #48bb78;
            --confidence-color-light: #68d391;
            color: #48bb78;
        }

        .card {
            background: #2d3748;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .card h3 {
            font-size: 20px;
            color: #f7fafc;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4a5568;
        }

        .chart-container {
            position: relative;
            height: 350px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #a0aec0;
            font-size: 16px;
        }

        .error-card {
            background: #4a2d32;
            border-left: 4px solid #e53e3e;
        }

        .error-card h3 {
            color: #e53e3e;
        }

        .warning-banner {
            background: #4a3b2a;
            border-left: 4px solid #ed8936;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: start;
        }

        .warning-icon {
            font-size: 24px;
        }

        .warning-content strong {
            display: block;
            color: #f6ad55;
            margin-bottom: 5px;
        }

        .warning-content p {
            color: #fbd38d;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Custom date range picker styles - Premium Design */
        .custom-range-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .custom-range-input {
            padding: 8px 16px;
            border: 2px solid #4fd1c5;
            background: #2d3748;
            color: #4fd1c5;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            min-width: 220px;
            text-align: center;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .custom-range-input::before {
            content: 'üìÖ';
            font-size: 14px;
        }

        .custom-range-input:hover {
            background: #1a202c;
        }

        .custom-range-input.active {
            background: #4fd1c5;
            color: #1a202c;
        }

        .custom-range-input:focus {
            outline: none;
        }

        /* Flatpickr dark theme customization - Premium */
        .flatpickr-calendar {
            background: linear-gradient(135deg, #2d3748 0%, #1e2836 100%);
            border: 1px solid rgba(79, 209, 197, 0.3);
            border-radius: 16px;
            box-shadow:
                0 12px 40px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(79, 209, 197, 0.1),
                0 0 60px rgba(79, 209, 197, 0.15);
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
        }

        .flatpickr-months {
            background: linear-gradient(180deg, #1a202c 0%, #2d3748 100%);
            border-bottom: 1px solid rgba(79, 209, 197, 0.2);
            padding: 12px;
        }

        .flatpickr-current-month {
            font-size: 16px;
            font-weight: 600;
            color: #4fd1c5;
        }

        .flatpickr-current-month .flatpickr-monthDropdown-months,
        .flatpickr-current-month input.cur-year {
            background: rgba(26, 32, 44, 0.6);
            color: #4fd1c5;
            border: 1px solid rgba(79, 209, 197, 0.2);
            border-radius: 6px;
            font-weight: 600;
            padding: 4px 8px;
        }

        .flatpickr-current-month .flatpickr-monthDropdown-months:hover,
        .flatpickr-current-month input.cur-year:hover {
            background: rgba(79, 209, 197, 0.1);
        }

        .flatpickr-weekdays {
            background: transparent;
            margin-top: 8px;
        }

        .flatpickr-weekday {
            color: #4fd1c5;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .flatpickr-days {
            border: none;
        }

        .flatpickr-day {
            color: #f7fafc;
            border-radius: 8px;
            transition: all 0.2s ease;
            font-weight: 500;
            border: 1px solid transparent;
        }

        .flatpickr-day.today {
            border-color: rgba(79, 209, 197, 0.5);
            font-weight: 700;
        }

        .flatpickr-day.selected,
        .flatpickr-day.startRange,
        .flatpickr-day.endRange {
            background: linear-gradient(135deg, #4fd1c5 0%, #38b2ac 100%);
            border-color: #4fd1c5;
            color: #1a202c;
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(79, 209, 197, 0.4);
        }

        .flatpickr-day.inRange {
            background: rgba(79, 209, 197, 0.15);
            border-color: rgba(79, 209, 197, 0.15);
            color: #f7fafc;
            box-shadow: none;
        }

        .flatpickr-day:hover:not(.selected):not(.startRange):not(.endRange) {
            background: rgba(79, 209, 197, 0.25);
            border-color: rgba(79, 209, 197, 0.4);
        }

        .flatpickr-day.prevMonthDay,
        .flatpickr-day.nextMonthDay {
            color: #4a5568;
        }

        .flatpickr-day.disabled {
            color: #2d3748;
        }

        /* Month navigation arrows */
        .flatpickr-months .flatpickr-prev-month,
        .flatpickr-months .flatpickr-next-month {
            fill: #4fd1c5;
            transition: all 0.2s ease;
        }

        .flatpickr-months .flatpickr-prev-month:hover,
        .flatpickr-months .flatpickr-next-month:hover {
            fill: #38b2ac;
            transform: scale(1.1);
        }

        .flatpickr-months .flatpickr-prev-month:hover svg,
        .flatpickr-months .flatpickr-next-month:hover svg {
            fill: #38b2ac;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
            }

            .controls-bar {
                flex-direction: column;
            }

            .time-range-selector {
                width: 100%;
                justify-content: space-between;
            }

            .range-btn {
                flex: 1;
                padding: 8px 12px;
                font-size: 12px;
            }

            .chart-container {
                height: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="page-title">Zone Insights</h1>
            <div class="breadcrumb">
                <a href="./">‚Üê Dashboard</a>
                <span style="color: #4a5568;">|</span>
                <a href="system-insights">System Insights ‚Üí</a>
            </div>
        </div>

        <div class="controls-bar">
            <!-- Date picker will be injected here by TheriaDatePicker -->
            <div id="date-picker-container"></div>
            <button class="refresh-btn" onclick="loadAllData()">üîÑ Refresh</button>
        </div>

        <div id="warning-container"></div>

        <div id="zone-overview" class="zone-overview-grid">
            <div class="loading">Loading zone data...</div>
        </div>

        <!-- Per-Climate Entity Charts -->
        <div id="climate-charts-container">
            <div class="loading">Loading climate entity charts...</div>
        </div>

        <!-- Zone Aggregate Chart -->
        <div class="card">
            <h3>Zone Aggregate - All Sensors</h3>
            <div class="chart-container">
                <canvas id="zoneAggregateChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Load external scripts (respects base tag) -->
    <script src="static/js/date-picker.js"></script>
    <script src="static/js/navigation.js"></script>

    <script>

        // Extract zone_id from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const zoneId = urlParams.get('zone_id') || 'butik';  // Default to butik for backward compatibility

        // Global state
        let currentZone = null;  // Will be loaded from API
        let zones = [];
        let charts = {
            climate: {},  // climate_entity_id -> Chart instance
            aggregate: null,
            mainHeating: null,
            heatCarrierDelta: null,
            compressorDelta: null,
            rates: null
        };
        let refreshInterval = null;
        let datePicker = null;

        // Color palette for zones
        const ZONE_COLORS = [
            ['#4fd1c5', '#38b2ac'],
            ['#b794f4', '#9f7aea'],
            ['#63b3ed', '#4299e1'],
            ['#f6ad55', '#ed8936']
        ];

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Load zone metadata first
            await loadZoneMetadata();

            // Load dynamic navigation
            await loadNavigation('zone', zoneId);

            // Initialize date picker with callback
            datePicker = new TheriaDatePicker('date-picker-container', {
                onRangeChange: () => loadAllData()
            });

            loadAllData();
            // Auto-refresh disabled for better analysis experience
            // startAutoRefresh();
        });

        // Load zone metadata from API
        async function loadZoneMetadata() {
            try {
                const res = await fetch('api/zones');
                const data = await res.json();
                zones = data.zones;

                currentZone = zones.find(z => z.id === zoneId);

                if (!currentZone) {
                    showError(`Zone "${zoneId}" not found in configuration. Available zones: ${zones.map(z => z.id).join(', ')}`);
                    return;
                }

                // Update page title and header dynamically
                document.title = `${currentZone.name} Zone Insights - Theria`;
                document.getElementById('page-title').innerHTML = `${currentZone.icon || 'üìä'} ${currentZone.name} Zone Insights`;

            } catch (error) {
                console.error('Error loading zone metadata:', error);
                showError('Failed to load zone configuration: ' + error.message);
            }
        }


        function startAutoRefresh() {
            // Refresh every 30 seconds
            refreshInterval = setInterval(() => {
                loadAllData(true); // Silent refresh
            }, 30000);
        }

        async function loadAllData(silent = false) {
            if (!currentZone) {
                showError('Zone configuration not loaded. Please refresh the page.');
                return;
            }

            if (!silent) {
                document.getElementById('zone-overview').innerHTML = '<div class="loading">Loading zone data...</div>';
            }

            try {
                // Load data for current zone in parallel
                const hours = datePicker.getHoursFromRange();
                await Promise.all([
                    loadZoneOverviews(),
                    loadClimateEntityCharts(hours),
                    loadZoneAggregateChart(hours)
                ]);

            } catch (error) {
                console.error('Error loading data:', error);
                showError('Failed to load data: ' + error.message);
            }
        }

        async function loadZoneOverviews() {
            const overviewHTML = [];
            const zone = currentZone;  // Only process current zone

            try {
                // Get thermal periods for current zone (period-based analysis)
                const hours = datePicker?.getTimeRange().hours || 24;
                const periodsRes = await fetch(`api/thermal/periods/${zone.id}?hours=${hours}`);
                const periodsData = await periodsRes.json();

                // Get zone status for current zone
                const statusRes = await fetch(`api/zones/${zone.id}/status`);
                const statusData = await statusRes.json();

                // Calculate zone-level statistics from periods
                const heatingPeriods = periodsData.periods.filter(p => p.type === 'heating');
                const coolingPeriods = periodsData.periods.filter(p => p.type === 'cooling');

                const heatingRate = heatingPeriods.length > 0
                    ? heatingPeriods.reduce((sum, p) => sum + p.rate, 0) / heatingPeriods.length
                    : 0;
                const coolingRate = coolingPeriods.length > 0
                    ? coolingPeriods.reduce((sum, p) => sum + p.rate, 0) / coolingPeriods.length
                    : 0;

                // Calculate confidence based on number and total duration of periods
                const totalPeriods = heatingPeriods.length + coolingPeriods.length;
                const totalDuration = periodsData.periods.reduce((sum, p) => sum + p.duration_hours, 0);
                const confidence = Math.min(1.0, totalPeriods / 20 + totalDuration / 100);

                const confidenceClass = confidence >= 0.7 ? 'confidence-high' :
                                          confidence >= 0.4 ? 'confidence-medium' : 'confidence-low';

                // Create charData-compatible object for existing display code
                const charData = {
                    heating_rate: heatingRate,
                    cooling_rate_base: coolingRate,
                    heating_samples: heatingPeriods.length,
                    cooling_samples: coolingPeriods.length,
                    overall_confidence: confidence
                };

                // Calculate period-specific statistics (not just "current")
                // Average temperature over the selected period from all period data
                const allPeriods = periodsData.periods;
                let periodAvgTemp = 0;
                let periodTargetTemp = null;

                if (allPeriods.length > 0) {
                    // Calculate weighted average temperature (weighted by duration)
                    let totalTempTime = 0;
                    let totalTime = 0;

                    allPeriods.forEach(period => {
                        const avgPeriodTemp = (period.start_temp + period.end_temp) / 2;
                        totalTempTime += avgPeriodTemp * period.duration_hours;
                        totalTime += period.duration_hours;
                    });

                    periodAvgTemp = totalTime > 0 ? totalTempTime / totalTime : 0;

                    // Use most recent period's target temp
                    const recentPeriod = allPeriods[allPeriods.length - 1];
                    periodTargetTemp = recentPeriod.target_temp;
                }

                // Fallback to current values if no period data
                const displayTemp = periodAvgTemp > 0 ? periodAvgTemp : (statusData.average_temperature || 0);
                const targetTemp = periodTargetTemp || statusData.climate_states?.[0]?.target_temperature;

                // Label for gauge (indicates time period)
                const periodLabel = datePicker?.selectedTimeRange || 'today';
                const tempLabel = periodAvgTemp > 0 ?
                    (periodLabel === 'today' ? 'Today Avg' :
                     periodLabel === 'yesterday' ? 'Yesterday' :
                     periodLabel === 'week' ? 'Week Avg' :
                     periodLabel === 'month' ? 'Month Avg' : 'Average')
                    : 'Current';

                    // Calculate gauge stroke-dashoffset (circumference = 264)
                    const gaugeOffset = 264 * (1 - confidence);

                    // Determine gauge gradient based on confidence
                    const gaugeGradientId = `gaugeGradient_${zone.id}`;
                    let gradientStops = '';
                    if (confidence >= 0.7) {
                        gradientStops = '<stop offset="0%" style="stop-color:#4fd1c5;stop-opacity:1" /><stop offset="100%" style="stop-color:#38b2ac;stop-opacity:1" />';
                    } else if (confidence >= 0.4) {
                        gradientStops = '<stop offset="0%" style="stop-color:#ed8936;stop-opacity:1" /><stop offset="100%" style="stop-color:#f6ad55;stop-opacity:1" />';
                    } else {
                        gradientStops = '<stop offset="0%" style="stop-color:#e53e3e;stop-opacity:1" /><stop offset="100%" style="stop-color:#fc8181;stop-opacity:1" />';
                    }

                    overviewHTML.push(`
                        <div class="zone-card">
                            <div class="zone-card-header">
                                <h3>${zone.name}</h3>
                            </div>

                            <div class="zone-content">
                                <!-- Left: Temperature Gauge -->
                                <div class="temp-gauge">
                                    <div class="gauge-container">
                                        <svg class="gauge-svg" viewBox="0 0 100 100">
                                            <defs>
                                                <linearGradient id="${gaugeGradientId}" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    ${gradientStops}
                                                </linearGradient>
                                            </defs>
                                            <circle class="gauge-bg" cx="50" cy="50" r="42" />
                                            <circle class="gauge-progress" cx="50" cy="50" r="42"
                                                    stroke-dasharray="264"
                                                    stroke-dashoffset="${gaugeOffset}"
                                                    style="stroke: url(#${gaugeGradientId})" />
                                        </svg>

                                        <div class="temp-display">
                                            <div class="current-temp">
                                                ${displayTemp.toFixed(1)}<span class="temp-unit">¬∞</span>
                                            </div>
                                            <div class="temp-label">${tempLabel}</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Right: Metrics Grid -->
                                <div class="zone-metrics">
                                    <!-- Target Temperature -->
                                    <div class="metric metric-target">
                                        <div class="metric-label">
                                            <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <path d="M12 2v20M17 7l-5-5-5 5"/>
                                            </svg>
                                            Target
                                        </div>
                                        <div class="metric-value">${targetTemp?.toFixed(1) || 'N/A'}¬∞</div>
                                    </div>

                                    <!-- Heating Rate -->
                                    <div class="metric metric-heating">
                                        <div class="metric-label">
                                            <svg class="metric-icon" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M12 2c.6 0 1 .4 1 1v3c0 .6-.4 1-1 1s-1-.4-1-1V3c0-.6.4-1 1-1zm0 15c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/>
                                            </svg>
                                            Heating
                                        </div>
                                        <div class="metric-value metric-value-small">
                                            <span class="rate-arrow heating-arrow">‚Üë</span>${charData.heating_rate >= 0 ? '+' : ''}${charData.heating_rate?.toFixed(2) || 'N/A'}¬∞/h
                                        </div>
                                    </div>

                                    <!-- Samples -->
                                    <div class="metric metric-samples">
                                        <div class="metric-label">
                                            <svg class="metric-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/>
                                                <rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/>
                                            </svg>
                                            Samples
                                        </div>
                                        <div class="metric-value metric-value-small">H:${charData.heating_samples || 0} C:${charData.cooling_samples || 0}</div>
                                    </div>

                                    <!-- Cooling Rate -->
                                    <div class="metric metric-cooling">
                                        <div class="metric-label">
                                            <svg class="metric-icon" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M12 2l1.5 5.5L19 9l-5.5 1.5L12 16l-1.5-5.5L5 9l5.5-1.5L12 2z"/>
                                            </svg>
                                            Cooling
                                        </div>
                                        <div class="metric-value metric-value-small">
                                            <span class="rate-arrow cooling-arrow">‚Üì</span>${charData.cooling_rate_base?.toFixed(2) || 'N/A'}¬∞/h
                                        </div>
                                    </div>

                                    <!-- Confidence (full width) -->
                                    <div class="confidence-metric">
                                        <div class="confidence-label-group">
                                            <div class="confidence-label">Confidence</div>
                                            <div class="confidence-value ${confidenceClass}">${(confidence * 100).toFixed(0)}%</div>
                                        </div>
                                        <div class="confidence-bar">
                                            <div class="confidence-fill ${confidenceClass}" style="width: ${(confidence * 100).toFixed(0)}%;"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                `);

                document.getElementById('zone-overview').innerHTML = overviewHTML.join('');

            } catch (error) {
                console.error(`Error loading zone ${zone.id}:`, error);
                showError(`Failed to load zone overview: ${error.message}`);
            }
        }

        async function loadClimateEntityCharts(hours) {
            const container = document.getElementById('climate-charts-container');
            container.innerHTML = '<div class="loading">Loading climate entity charts...</div>';

            // Build API URL with date range for current zone
            const apiUrl = datePicker.buildChartDataUrl(`api/zones/${zoneId}/chart_data`);

            // Collect climate entities for current zone using unified endpoint
            const climateCharts = [];
            const zone = currentZone;

            try {
                // ONE API call gets EVERYTHING: datasets + annotations!
                const res = await fetch(apiUrl);
                const chartData = await res.json();

                if (!chartData.datasets || chartData.datasets.length === 0) {
                    container.innerHTML = '<div class="card"><p>No climate entity data available for this zone</p></div>';
                    return;
                }

                // Extract unique entity IDs from datasets (backend now includes entity_id field)
                const entityMap = new Map(); // entity_id -> entity_name
                chartData.datasets.forEach(ds => {
                    if (ds.entity_id) {
                        const match = ds.label.match(/^(.+?) - (Current|Target|Heating %)/);
                        if (match) {
                            entityMap.set(ds.entity_id, match[1]); // Store entity_id -> friendly name mapping
                        }
                    }
                });

                // Separate datasets and annotations by entity
                for (const [entityId, entityName] of entityMap) {
                    // Filter datasets for THIS entity using entity_id field
                    const entityDatasets = chartData.datasets.filter(ds => ds.entity_id === entityId);

                    // Filter annotations for THIS entity using entity_id field
                    const entityAnnotations = {};
                    Object.entries(chartData.annotations).forEach(([key, annotation]) => {
                        if (annotation.entity_id === entityId) {
                            entityAnnotations[key] = annotation;
                        }
                    });

                    climateCharts.push({
                        zone: zone.name,
                        zoneId: zone.id,
                        entity: entityId,
                        entityName: entityName,
                        datasets: entityDatasets,
                        annotations: entityAnnotations,
                        scales: chartData.scales
                    });
                }

            } catch (error) {
                console.error(`Error loading climate charts for ${zone.id}:`, error);
                container.innerHTML = `<div class="card error-card"><h3>‚ö†Ô∏è Error</h3><p>Failed to load climate charts: ${error.message}</p></div>`;
                return;
            }

            // Generate HTML for all climate entity charts
            let chartsHTML = '';
            for (const chartData of climateCharts) {
                const canvasId = `climate-chart-${chartData.entity.replace(/\./g, '-')}`;
                chartsHTML += `
                    <div class="card">
                        <h3>${chartData.zone} - ${chartData.entityName}</h3>
                        <div class="chart-container">
                            <canvas id="${canvasId}"></canvas>
                        </div>
                    </div>
                `;
            }

            container.innerHTML = chartsHTML || '<div class="card"><p>No climate entity data available</p></div>';

            // Create Chart.js instances for each climate entity - ZERO transformation needed!
            for (const chartData of climateCharts) {
                const canvasId = `climate-chart-${chartData.entity.replace(/\./g, '-')}`;
                const ctx = document.getElementById(canvasId);
                if (!ctx) continue;

                // Destroy existing chart if any
                if (charts.climate[chartData.entity]) {
                    charts.climate[chartData.entity].destroy();
                }

                // Use backend-provided datasets and annotations directly
                // Add ticks callback for y1 axis (can't be serialized in JSON)
                const scales = chartData.scales;
                if (scales.y1 && scales.y1.ticks) {
                    scales.y1.ticks.callback = function(value) {
                        return value + '%';
                    };
                }

                charts.climate[chartData.entity] = new Chart(ctx, {
                    type: 'line',
                    data: { datasets: chartData.datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: { boxWidth: 12, padding: 8, font: { size: 11 }, color: '#a0aec0' }
                            },
                            annotation: {
                                annotations: chartData.annotations
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.parsed.y !== null) {
                                            if (context.dataset.yAxisID === 'y1') {
                                                label += context.parsed.y.toFixed(0) + '%';
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '¬∞C';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: scales
                    }
                });
            }
        }

        async function loadZoneAggregateChart(hours) {
            const datasets = [];

            // Get time bounds for x-axis from datePicker
            const { xAxisMin, xAxisMax } = datePicker.getTimeBounds();

            // Process current zone only
            const zone = currentZone;
            const zoneIdx = 0;  // Single zone, use index 0 for colors

            try {
                // Fetch temperature history with date range
                const historyUrl = datePicker.buildChartDataUrl(`/api/zones/${zone.id}/history`);
                const res = await fetch(historyUrl);
                const tempData = await res.json();

                // Fetch heating power timeline with date range
                const heatingUrl = datePicker.buildChartDataUrl(`/api/zones/${zone.id}/heating_timeline`);
                const heatingRes = await fetch(heatingUrl);
                const heatingData = await heatingRes.json();

                if (!tempData.history || tempData.history.length === 0) {
                    console.warn(`No temperature history data for zone ${zone.id}`);
                    // Continue with empty datasets - will show empty chart
                }

                // Zone average temperature
                if (tempData.history && tempData.history.length > 0) {
                    const zoneAvgData = tempData.history.map(h => ({
                        x: new Date(h.timestamp),
                        y: h.current_temp
                    }));

                    datasets.push({
                        label: `${zone.name} - Average`,
                        data: zoneAvgData,
                        borderColor: ZONE_COLORS[zoneIdx][0],
                        backgroundColor: `${ZONE_COLORS[zoneIdx][0]}30`,
                        borderWidth: 3,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 5,
                        yAxisID: 'y'
                    });

                    // Individual sensor temperatures
                    const sensorDatasets = {};
                    tempData.history.forEach(h => {
                        if (h.current_temps) {
                            Object.entries(h.current_temps).forEach(([entity, temp]) => {
                                if (!sensorDatasets[entity]) {
                                    sensorDatasets[entity] = [];
                                }
                                sensorDatasets[entity].push({ x: new Date(h.timestamp), y: temp });
                            });
                        }
                    });

                    // Predefined color palette for maximum sensor distinction
                    // Each sensor gets a completely different color (not variations of base color)
                    function getSensorColor(index) {
                        const sensorColorPalette = [
                            '#4fd1c5',  // Teal (original zone color)
                            '#f6ad55',  // Orange
                            '#b794f4',  // Purple
                            '#68d391',  // Lime/Green
                            '#fc8181',  // Pink/Red
                            '#63b3ed',  // Sky Blue
                            '#fbd38d',  // Yellow
                            '#f687b3'   // Hot Pink
                        ];
                        return sensorColorPalette[index % sensorColorPalette.length];
                    }

                    // Assign distinct colors to each sensor
                    const sensorEntities = Object.keys(sensorDatasets);
                    Object.entries(sensorDatasets).forEach(([entity, data], sensorIdx) => {
                        const entityName = entity.replace('climate.', '').replace('sensor.', '');

                        // Get distinct color for this sensor from predefined palette
                        const sensorColor = getSensorColor(sensorIdx);

                        datasets.push({
                            label: `${zone.name} - ${entityName}`,
                            data: data,
                            borderColor: sensorColor,
                            borderWidth: 1.5,
                            tension: 0.3,
                            pointRadius: 0,
                            fill: false,
                            yAxisID: 'y'
                        });
                    });
                }

                // Heating activity overlay
                if (heatingData.timeline && heatingData.timeline.length > 0) {
                    const heatingDataMapped = heatingData.timeline.map(h => ({
                        x: new Date(h.timestamp),
                        y: h.avg_heating_request
                    }));

                    datasets.push({
                        label: `${zone.name} - Heating %`,
                        data: heatingDataMapped,
                        borderColor: `${ZONE_COLORS[zoneIdx][1]}80`,
                        backgroundColor: `${ZONE_COLORS[zoneIdx][1]}30`,
                        borderWidth: 1.5,
                        tension: 0.2,
                        pointRadius: 0,
                        fill: true,
                        yAxisID: 'y1',
                        stepped: 'before'
                    });
                }

            } catch (error) {
                console.error(`Error loading zone aggregate for ${zone.id}:`, error);
            }

            const ctx = document.getElementById('zoneAggregateChart');
            if (charts.aggregate) {
                charts.aggregate.destroy();
            }

            charts.aggregate = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { boxWidth: 12, padding: 8, font: { size: 10 }, color: '#a0aec0' }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) {
                                        if (context.dataset.yAxisID === 'y1') {
                                            label += context.parsed.y.toFixed(0) + '%';
                                        } else {
                                            label += context.parsed.y.toFixed(1) + '¬∞C';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: hours <= 48 ? 'hour' : 'day',  // Match backend logic
                                displayFormats: {
                                    hour: 'HH:mm',
                                    day: 'MMM dd'
                                },
                                tooltipFormat: 'PPpp'
                            },
                            min: xAxisMin,  // Set explicit time bounds
                            max: xAxisMax,  // Set explicit time bounds
                            ticks: {
                                color: '#a0aec0',
                                maxRotation: 0,
                                minRotation: 0,
                                maxTicksLimit: 12
                            },
                            grid: { display: false }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'Temperature (¬∞C)', color: '#a0aec0' },
                            suggestedMin: 15,
                            suggestedMax: 25,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#a0aec0' }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Heating Request (%)', color: '#a0aec0' },
                            min: 0,
                            max: 100,
                            grid: { display: false },
                            ticks: {
                                color: '#a0aec0',
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }




        async function loadTemperatureChart(hours) {
            const datasets = [];

            // Generate fixed time axis from (now - hours) to now, rounded to full hours
            const now = new Date();
            const currentMinutes = now.getMinutes();
            now.setMinutes(0, 0, 0); // Round down to current hour

            // If we're past the hour start, round up to next hour to include current partial hour
            if (currentMinutes > 0) {
                now.setHours(now.getHours() + 1);
            }

            const startTime = new Date(now.getTime() - hours * 60 * 60 * 1000);
            startTime.setMinutes(0, 0, 0); // Round down to full hour

            // Determine interval based on time range
            let intervalMinutes;
            if (hours <= 1) {
                intervalMinutes = 5; // 5-minute intervals for 1 hour
            } else if (hours <= 6) {
                intervalMinutes = 15; // 15-minute intervals for up to 6 hours
            } else if (hours <= 48) {
                intervalMinutes = 60; // Hourly for 1-2 days
            } else if (hours <= 168) {
                intervalMinutes = 360; // 6-hour intervals for week
            } else {
                intervalMinutes = 1440; // Daily for month
            }

            // Generate time slots and labels
            const timeSlots = [];
            const labels = [];
            for (let t = startTime.getTime(); t <= now.getTime(); t += intervalMinutes * 60 * 1000) {
                const slotTime = new Date(t);
                timeSlots.push(slotTime);

                if (hours <= 48) {
                    // Show hour for short ranges
                    labels.push(slotTime.toLocaleTimeString('sv-SE', { hour: '2-digit', minute: '2-digit' }));
                } else {
                    // Show date for longer ranges
                    labels.push(slotTime.toLocaleDateString('sv-SE', { month: 'short', day: 'numeric' }));
                }
            }

            // Collect all data
            const zoneDataList = [];
            for (let i = 0; i < zones.length; i++) {
                const zone = zones[i];
                try {
                    // Fetch temperature history
                    const res = await fetch(`api/zones/${zone.id}/history?hours=${hours}`);
                    const tempData = await res.json();

                    // Fetch heating power timeline
                    const heatingRes = await fetch(`api/zones/${zone.id}/heating_timeline?hours=${hours}`);
                    const heatingData = await heatingRes.json();

                    zoneDataList.push({
                        zone,
                        tempData,
                        heatingData,
                        colorIndex: i
                    });
                } catch (error) {
                    console.error(`Error loading data for ${zone.id}:`, error);
                }
            }

            // Helper to find nearest time slot for a timestamp
            function findNearestSlot(timestamp) {
                const time = new Date(timestamp).getTime();
                let nearestIdx = 0;
                let minDiff = Math.abs(timeSlots[0].getTime() - time);

                for (let i = 1; i < timeSlots.length; i++) {
                    const diff = Math.abs(timeSlots[i].getTime() - time);
                    if (diff < minDiff) {
                        minDiff = diff;
                        nearestIdx = i;
                    }
                }
                return nearestIdx;
            }

            // Build datasets
            for (const {zone, tempData, heatingData, colorIndex} of zoneDataList) {
                // Initialize arrays with nulls for the full time range
                const tempArray = new Array(timeSlots.length).fill(null);
                const targetArray = new Array(timeSlots.length).fill(null);
                const heatingArray = new Array(timeSlots.length).fill(null);

                // Debug logging
                console.log(`Zone ${zone.name}: Processing ${tempData.history?.length || 0} temp readings, ${heatingData.timeline?.length || 0} heating readings`);
                console.log('Time range:', startTime.toISOString(), 'to', now.toISOString());
                console.log('Time slots:', timeSlots.length, 'slots');

                // Map temperature data to nearest time slots
                if (tempData.history && tempData.history.length > 0) {
                    tempData.history.forEach(h => {
                        const idx = findNearestSlot(h.timestamp);
                        tempArray[idx] = h.current_temp;
                        if (h.scheduled_temp) {
                            targetArray[idx] = h.scheduled_temp;
                        }
                        // Debug first few mappings
                        if (tempData.history.indexOf(h) < 3) {
                            console.log(`  Data point: ${h.timestamp} -> slot ${idx} (${labels[idx]}), temp: ${h.current_temp}`);
                        }
                    });

                    // Add temperature dataset
                    datasets.push({
                        label: `${zone.name} - Temp`,
                        data: tempArray,
                        borderColor: ZONE_COLORS[colorIndex][0],
                        backgroundColor: `${ZONE_COLORS[colorIndex][0]}20`,
                        borderWidth: 2.5,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 5,
                        yAxisID: 'y',
                        spanGaps: true
                    });

                    // Add target temp (if available)
                    if (targetArray.some(v => v !== null)) {
                        datasets.push({
                            label: `${zone.name} - Target`,
                            data: targetArray,
                            borderColor: ZONE_COLORS[colorIndex][0],
                            borderWidth: 1.5,
                            borderDash: [5, 5],
                            tension: 0,
                            pointRadius: 0,
                            fill: false,
                            yAxisID: 'y',
                            spanGaps: true
                        });
                    }
                }

                // Map heating power data to nearest time slots
                if (heatingData.timeline && heatingData.timeline.length > 0) {
                    heatingData.timeline.forEach(h => {
                        const idx = findNearestSlot(h.timestamp);
                        heatingArray[idx] = h.avg_heating_request;
                    });

                    datasets.push({
                        label: `${zone.name} - Heating %`,
                        data: heatingArray,
                        borderColor: `${ZONE_COLORS[colorIndex][1]}80`,
                        backgroundColor: `${ZONE_COLORS[colorIndex][1]}30`,
                        borderWidth: 1.5,
                        tension: 0.2,
                        pointRadius: 0,
                        fill: true,
                        yAxisID: 'y1',
                        stepped: 'before',
                        spanGaps: true
                    });
                }
            }

            const ctx = document.getElementById('tempChart');
            if (charts.temp) {
                charts.temp.destroy();
            }

            charts.temp = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { boxWidth: 12, padding: 8, font: { size: 11 }, color: '#a0aec0' }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        if (context.dataset.yAxisID === 'y1') {
                                            label += context.parsed.y.toFixed(0) + '%';
                                        } else {
                                            label += context.parsed.y.toFixed(1) + '¬∞C';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            ticks: {
                                color: '#a0aec0',
                                autoSkip: true,
                                maxTicksLimit: 12,
                                maxRotation: 0,
                                minRotation: 0
                            },
                            grid: { display: false }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'Temperature (¬∞C)', color: '#a0aec0' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#a0aec0' }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Heating Request (%)', color: '#a0aec0' },
                            min: 0,
                            max: 100,
                            grid: { display: false },
                            ticks: {
                                color: '#a0aec0',
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }


        function showWarning(title, message) {
            const container = document.getElementById('warning-container');
            const existing = container.querySelector('.warning-banner');
            if (!existing) {
                container.innerHTML = `
                    <div class="warning-banner">
                        <div class="warning-icon">‚ö†Ô∏è</div>
                        <div class="warning-content">
                            <strong>${title}</strong>
                            <p>${message}</p>
                        </div>
                    </div>
                `;
            }
        }

        function showError(message) {
            document.getElementById('zone-overview').innerHTML = `
                <div class="card error-card">
                    <h3>‚ö†Ô∏è Error</h3>
                    <p>${message}</p>
                </div>
            `;
        }
    </script>
</body>
</html>
